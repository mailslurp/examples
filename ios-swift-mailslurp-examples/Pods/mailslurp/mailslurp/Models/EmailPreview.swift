//
// EmailPreview.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Preview of an email message. For full message (including body and attachments) call the `getEmail` or other email endpoints with the provided email ID. */
@objc public class EmailPreview: NSObject, Codable, JSONEncodable {

    /** ID of the email entity */
    public var _id: UUID
    /** ID of the domain that received the email */
    public var domainId: UUID?
    /** The subject line of the email message as specified by SMTP subject header */
    public var subject: String?
    /** List of `To` recipient email addresses that the email was addressed to. See recipients object for names. */
    public var to: [String]?
    /** Who the email was sent from. An email address - see fromName for the sender name. */
    public var from: String?
    /** List of `BCC` recipients email addresses that the email was addressed to. See recipients object for names. */
    public var bcc: [String]?
    /** List of `CC` recipients email addresses that the email was addressed to. See recipients object for names. */
    public var cc: [String]?
    /** When was the email received by MailSlurp */
    public var createdAt: Date
    /** Read flag. Has the email ever been viewed in the dashboard or fetched via the API with a hydrated body? If so the email is marked as read. Paginated results do not affect read status. Read status is different to email opened event as it depends on your own account accessing the email. Email opened is determined by tracking pixels sent to other uses if enable during sending. You can listened for both email read and email opened events using webhooks. */
    public var read: Bool
    /** List of IDs of attachments found in the email. Use these IDs with the Inbox and Email Controllers to download attachments and attachment meta data such as filesize, name, extension. */
    public var attachments: [String]?

    public init(_id: UUID, domainId: UUID? = nil, subject: String? = nil, to: [String]?, from: String? = nil, bcc: [String]? = nil, cc: [String]? = nil, createdAt: Date, read: Bool, attachments: [String]? = nil) {
        self._id = _id
        self.domainId = domainId
        self.subject = subject
        self.to = to
        self.from = from
        self.bcc = bcc
        self.cc = cc
        self.createdAt = createdAt
        self.read = read
        self.attachments = attachments
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case _id = "id"
        case domainId
        case subject
        case to
        case from
        case bcc
        case cc
        case createdAt
        case read
        case attachments
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(_id, forKey: ._id)
        try container.encodeIfPresent(domainId, forKey: .domainId)
        try container.encodeIfPresent(subject, forKey: .subject)
        try container.encode(to, forKey: .to)
        try container.encodeIfPresent(from, forKey: .from)
        try container.encodeIfPresent(bcc, forKey: .bcc)
        try container.encodeIfPresent(cc, forKey: .cc)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(read, forKey: .read)
        try container.encodeIfPresent(attachments, forKey: .attachments)
    }
}


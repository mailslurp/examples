//
// WebhookNewSmsPayload.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** NEW_SMS webhook payload. Sent to your webhook url endpoint via HTTP POST when an sms is received by the phone number that your webhook is attached to. Use the SMS ID to fetch the full SMS details. */
@objc public class WebhookNewSmsPayload: NSObject, Codable, JSONEncodable {

    public enum EventName: String, Codable, CaseIterable {
        case emailReceived = "EMAIL_RECEIVED"
        case newEmail = "NEW_EMAIL"
        case newContact = "NEW_CONTACT"
        case newAttachment = "NEW_ATTACHMENT"
        case emailOpened = "EMAIL_OPENED"
        case emailRead = "EMAIL_READ"
        case deliveryStatus = "DELIVERY_STATUS"
        case bounce = "BOUNCE"
        case bounceRecipient = "BOUNCE_RECIPIENT"
        case newSms = "NEW_SMS"
    }
    /** Idempotent message ID. Store this ID locally or in a database to prevent message duplication. */
    public var messageId: String
    /** ID of webhook entity being triggered */
    public var webhookId: UUID
    /** Name of the event type webhook is being triggered for. */
    public var eventName: EventName
    /** Name of the webhook being triggered */
    public var webhookName: String?
    /** ID of SMS message */
    public var smsId: UUID
    /** User ID of event */
    public var userId: UUID
    /** ID of phone number receiving SMS */
    public var phoneNumber: UUID
    /** Recipient phone number */
    public var toNumber: String
    /** Sender phone number */
    public var fromNumber: String
    /** SMS message body */
    public var body: String
    /** SMS has been read */
    public var read: Bool

    public init(messageId: String, webhookId: UUID, eventName: EventName, webhookName: String? = nil, smsId: UUID, userId: UUID, phoneNumber: UUID, toNumber: String, fromNumber: String, body: String, read: Bool) {
        self.messageId = messageId
        self.webhookId = webhookId
        self.eventName = eventName
        self.webhookName = webhookName
        self.smsId = smsId
        self.userId = userId
        self.phoneNumber = phoneNumber
        self.toNumber = toNumber
        self.fromNumber = fromNumber
        self.body = body
        self.read = read
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case messageId
        case webhookId
        case eventName
        case webhookName
        case smsId
        case userId
        case phoneNumber
        case toNumber
        case fromNumber
        case body
        case read
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(messageId, forKey: .messageId)
        try container.encode(webhookId, forKey: .webhookId)
        try container.encode(eventName, forKey: .eventName)
        try container.encodeIfPresent(webhookName, forKey: .webhookName)
        try container.encode(smsId, forKey: .smsId)
        try container.encode(userId, forKey: .userId)
        try container.encode(phoneNumber, forKey: .phoneNumber)
        try container.encode(toNumber, forKey: .toNumber)
        try container.encode(fromNumber, forKey: .fromNumber)
        try container.encode(body, forKey: .body)
        try container.encode(read, forKey: .read)
    }
}


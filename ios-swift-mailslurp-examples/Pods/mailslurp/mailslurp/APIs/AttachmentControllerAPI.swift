//
// AttachmentControllerAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import PromiseKit
#if canImport(AnyCodable)
import AnyCodable
#endif

@objc open class AttachmentControllerAPI : NSObject {

    /**
     Delete all attachments
     
     - returns: Promise<Void>
     */
    open class func deleteAllAttachments() -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteAllAttachmentsWithRequestBuilder().execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete all attachments
     - DELETE /attachments
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - returns: RequestBuilder<Void> 
     */
    open class func deleteAllAttachmentsWithRequestBuilder() -> RequestBuilder<Void> {
        let localVariablePath = "/attachments"
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = mailslurpAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Delete an attachment
     
     - parameter attachmentId: (path) ID of attachment 
     - returns: Promise<Void>
     */
    open class func deleteAttachment( attachmentId: String) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteAttachmentWithRequestBuilder(attachmentId: attachmentId).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete an attachment
     - DELETE /attachments/{attachmentId}
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter attachmentId: (path) ID of attachment 
     - returns: RequestBuilder<Void> 
     */
    open class func deleteAttachmentWithRequestBuilder(attachmentId: String) -> RequestBuilder<Void> {
        var localVariablePath = "/attachments/{attachmentId}"
        let attachmentIdPreEscape = "\(APIHelper.mapValueToPathItem(attachmentId))"
        let attachmentIdPostEscape = attachmentIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{attachmentId}", with: attachmentIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = mailslurpAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Get email attachment as base64 encoded string as alternative to binary responses. To read the content decode the Base64 encoded contents.
     
     - parameter attachmentId: (path) ID of attachment 
     - returns: Promise<DownloadAttachmentDto>
     */
    open class func downloadAttachmentAsBase64Encoded( attachmentId: String) -> Promise<DownloadAttachmentDto> {
        let deferred = Promise<DownloadAttachmentDto>.pending()
        downloadAttachmentAsBase64EncodedWithRequestBuilder(attachmentId: attachmentId).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get email attachment as base64 encoded string as alternative to binary responses. To read the content decode the Base64 encoded contents.
     - GET /attachments/{attachmentId}/base64
     - Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter attachmentId: (path) ID of attachment 
     - returns: RequestBuilder<DownloadAttachmentDto> 
     */
    open class func downloadAttachmentAsBase64EncodedWithRequestBuilder(attachmentId: String) -> RequestBuilder<DownloadAttachmentDto> {
        var localVariablePath = "/attachments/{attachmentId}/base64"
        let attachmentIdPreEscape = "\(APIHelper.mapValueToPathItem(attachmentId))"
        let attachmentIdPostEscape = attachmentIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{attachmentId}", with: attachmentIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<DownloadAttachmentDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Download attachments. Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
     
     - parameter attachmentId: (path) ID of attachment 
     - returns: Promise<Data>
     */
    open class func downloadAttachmentAsBytes( attachmentId: String) -> Promise<Data> {
        let deferred = Promise<Data>.pending()
        downloadAttachmentAsBytesWithRequestBuilder(attachmentId: attachmentId).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Download attachments. Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
     - GET /attachments/{attachmentId}/bytes
     - Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter attachmentId: (path) ID of attachment 
     - returns: RequestBuilder<Data> 
     */
    open class func downloadAttachmentAsBytesWithRequestBuilder(attachmentId: String) -> RequestBuilder<Data> {
        var localVariablePath = "/attachments/{attachmentId}/bytes"
        let attachmentIdPreEscape = "\(APIHelper.mapValueToPathItem(attachmentId))"
        let attachmentIdPostEscape = attachmentIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{attachmentId}", with: attachmentIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Data>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Get an attachment entity
     
     - parameter attachmentId: (path) ID of attachment 
     - returns: Promise<AttachmentEntity>
     */
    open class func getAttachment( attachmentId: String) -> Promise<AttachmentEntity> {
        let deferred = Promise<AttachmentEntity>.pending()
        getAttachmentWithRequestBuilder(attachmentId: attachmentId).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get an attachment entity
     - GET /attachments/{attachmentId}
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter attachmentId: (path) ID of attachment 
     - returns: RequestBuilder<AttachmentEntity> 
     */
    open class func getAttachmentWithRequestBuilder(attachmentId: String) -> RequestBuilder<AttachmentEntity> {
        var localVariablePath = "/attachments/{attachmentId}"
        let attachmentIdPreEscape = "\(APIHelper.mapValueToPathItem(attachmentId))"
        let attachmentIdPostEscape = attachmentIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{attachmentId}", with: attachmentIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AttachmentEntity>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Get email attachment metadata information
     
     - parameter attachmentId: (path) ID of attachment 
     - returns: Promise<AttachmentMetaData>
     */
    open class func getAttachmentInfo( attachmentId: String) -> Promise<AttachmentMetaData> {
        let deferred = Promise<AttachmentMetaData>.pending()
        getAttachmentInfoWithRequestBuilder(attachmentId: attachmentId).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get email attachment metadata information
     - GET /attachments/{attachmentId}/metadata
     - Returns the metadata for an attachment. It is saved separately to the content of the attachment. Contains properties `name` and `content-type` and `content-length` in bytes for a given attachment.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter attachmentId: (path) ID of attachment 
     - returns: RequestBuilder<AttachmentMetaData> 
     */
    open class func getAttachmentInfoWithRequestBuilder(attachmentId: String) -> RequestBuilder<AttachmentMetaData> {
        var localVariablePath = "/attachments/{attachmentId}/metadata"
        let attachmentIdPreEscape = "\(APIHelper.mapValueToPathItem(attachmentId))"
        let attachmentIdPostEscape = attachmentIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{attachmentId}", with: attachmentIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AttachmentMetaData>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getAttachments: String, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**
     Get email attachments
     
     - parameter page: (query) Optional page index for list pagination (optional, default to 0)
     - parameter size: (query) Optional page size for list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter fileNameFilter: (query) Optional file name and content type search filter (optional)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter inboxId: (query) Optional inboxId to filter attachments by (optional)
     - returns: Promise<PageAttachmentEntity>
     */
    open class func getAttachments( page: Int? = nil,  size: Int? = nil,  sort: Sort_getAttachments? = nil,  fileNameFilter: String? = nil,  since: Date? = nil,  before: Date? = nil,  inboxId: UUID? = nil) -> Promise<PageAttachmentEntity> {
        let deferred = Promise<PageAttachmentEntity>.pending()
        getAttachmentsWithRequestBuilder(page: page, size: size, sort: sort, fileNameFilter: fileNameFilter, since: since, before: before, inboxId: inboxId).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get email attachments
     - GET /attachments
     - Get all attachments in paginated response. Each entity contains meta data for the attachment such as `name` and `content-type`. Use the `attachmentId` and the download endpoints to get the file contents.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter page: (query) Optional page index for list pagination (optional, default to 0)
     - parameter size: (query) Optional page size for list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter fileNameFilter: (query) Optional file name and content type search filter (optional)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter inboxId: (query) Optional inboxId to filter attachments by (optional)
     - returns: RequestBuilder<PageAttachmentEntity> 
     */
    open class func getAttachmentsWithRequestBuilder(page: Int? = nil, size: Int? = nil, sort: Sort_getAttachments? = nil, fileNameFilter: String? = nil, since: Date? = nil, before: Date? = nil, inboxId: UUID? = nil) -> RequestBuilder<PageAttachmentEntity> {
        let localVariablePath = "/attachments"
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "page": (wrappedValue: page?.encodeToJSON(), isExplode: true),
            "size": (wrappedValue: size?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
            "fileNameFilter": (wrappedValue: fileNameFilter?.encodeToJSON(), isExplode: true),
            "since": (wrappedValue: since?.encodeToJSON(), isExplode: true),
            "before": (wrappedValue: before?.encodeToJSON(), isExplode: true),
            "inboxId": (wrappedValue: inboxId?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PageAttachmentEntity>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
     
     - parameter uploadAttachmentOptions: (body)  
     - returns: Promise<[String]>
     */
    open class func uploadAttachment( uploadAttachmentOptions: UploadAttachmentOptions) -> Promise<[String]> {
        let deferred = Promise<[String]>.pending()
        uploadAttachmentWithRequestBuilder(uploadAttachmentOptions: uploadAttachmentOptions).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
     - POST /attachments
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter uploadAttachmentOptions: (body)  
     - returns: RequestBuilder<[String]> 
     */
    open class func uploadAttachmentWithRequestBuilder(uploadAttachmentOptions: UploadAttachmentOptions) -> RequestBuilder<[String]> {
        let localVariablePath = "/attachments"
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: uploadAttachmentOptions)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[String]>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
     
     - parameter contentType: (header)  (optional)
     - parameter contentType2: (query) Optional contentType for file. For instance `application/pdf` (optional)
     - parameter contentId: (query) Optional content ID (CID) to save upload with (optional)
     - parameter filename: (query) Optional filename to save upload with (optional)
     - parameter filename2: (header)  (optional)
     - returns: Promise<[String]>
     */
    open class func uploadAttachmentBytes( contentType: String? = nil,  contentType2: String? = nil,  contentId: String? = nil,  filename: String? = nil,  filename2: String? = nil) -> Promise<[String]> {
        let deferred = Promise<[String]>.pending()
        uploadAttachmentBytesWithRequestBuilder(contentType: contentType, contentType2: contentType2, contentId: contentId, filename: filename, filename2: filename2).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
     - POST /attachments/bytes
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter contentType: (header)  (optional)
     - parameter contentType2: (query) Optional contentType for file. For instance `application/pdf` (optional)
     - parameter contentId: (query) Optional content ID (CID) to save upload with (optional)
     - parameter filename: (query) Optional filename to save upload with (optional)
     - parameter filename2: (header)  (optional)
     - returns: RequestBuilder<[String]> 
     */
    open class func uploadAttachmentBytesWithRequestBuilder(contentType: String? = nil, contentType2: String? = nil, contentId: String? = nil, filename: String? = nil, filename2: String? = nil) -> RequestBuilder<[String]> {
        let localVariablePath = "/attachments/bytes"
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "contentType": (wrappedValue: contentType2?.encodeToJSON(), isExplode: true),
            "contentId": (wrappedValue: contentId?.encodeToJSON(), isExplode: true),
            "filename": (wrappedValue: filename?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            "contentType": contentType?.encodeToJSON(),
            "filename": filename2?.encodeToJSON(),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[String]>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
     
     - parameter contentId: (query) Optional content ID of attachment (optional)
     - parameter contentType: (query) Optional content type of attachment (optional)
     - parameter filename: (query) Optional name of file (optional)
     - parameter xFilename: (query) Optional content type header of attachment (optional)
     - parameter uploadMultipartFormRequest: (body)  (optional)
     - returns: Promise<[String]>
     */
    open class func uploadMultipartForm( contentId: String? = nil,  contentType: String? = nil,  filename: String? = nil,  xFilename: String? = nil,  uploadMultipartFormRequest: UploadMultipartFormRequest? = nil) -> Promise<[String]> {
        let deferred = Promise<[String]>.pending()
        uploadMultipartFormWithRequestBuilder(contentId: contentId, contentType: contentType, filename: filename, xFilename: xFilename, uploadMultipartFormRequest: uploadMultipartFormRequest).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
     - POST /attachments/multipart
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter contentId: (query) Optional content ID of attachment (optional)
     - parameter contentType: (query) Optional content type of attachment (optional)
     - parameter filename: (query) Optional name of file (optional)
     - parameter xFilename: (query) Optional content type header of attachment (optional)
     - parameter uploadMultipartFormRequest: (body)  (optional)
     - returns: RequestBuilder<[String]> 
     */
    open class func uploadMultipartFormWithRequestBuilder(contentId: String? = nil, contentType: String? = nil, filename: String? = nil, xFilename: String? = nil, uploadMultipartFormRequest: UploadMultipartFormRequest? = nil) -> RequestBuilder<[String]> {
        let localVariablePath = "/attachments/multipart"
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: uploadMultipartFormRequest)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "contentId": (wrappedValue: contentId?.encodeToJSON(), isExplode: true),
            "contentType": (wrappedValue: contentType?.encodeToJSON(), isExplode: true),
            "filename": (wrappedValue: filename?.encodeToJSON(), isExplode: true),
            "x-filename": (wrappedValue: xFilename?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[String]>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }
}

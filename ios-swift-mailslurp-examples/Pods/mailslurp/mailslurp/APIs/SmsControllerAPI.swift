//
// SmsControllerAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import PromiseKit
#if canImport(AnyCodable)
import AnyCodable
#endif

@objc open class SmsControllerAPI : NSObject {

    /**
     Delete SMS message.
     
     - parameter smsId: (path)  
     - returns: Promise<Void>
     */
    open class func deleteSmsMessage( smsId: UUID) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteSmsMessageWithRequestBuilder(smsId: smsId).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete SMS message.
     - DELETE /sms/{smsId}
     - Delete an SMS message
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter smsId: (path)  
     - returns: RequestBuilder<Void> 
     */
    open class func deleteSmsMessageWithRequestBuilder(smsId: UUID) -> RequestBuilder<Void> {
        var localVariablePath = "/sms/{smsId}"
        let smsIdPreEscape = "\(APIHelper.mapValueToPathItem(smsId))"
        let smsIdPostEscape = smsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{smsId}", with: smsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = mailslurpAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Delete all SMS messages
     
     - parameter phoneNumberId: (query)  (optional)
     - returns: Promise<Void>
     */
    open class func deleteSmsMessages( phoneNumberId: UUID? = nil) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteSmsMessagesWithRequestBuilder(phoneNumberId: phoneNumberId).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete all SMS messages
     - DELETE /sms
     - Delete all SMS messages or all messages for a given phone number
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter phoneNumberId: (query)  (optional)
     - returns: RequestBuilder<Void> 
     */
    open class func deleteSmsMessagesWithRequestBuilder(phoneNumberId: UUID? = nil) -> RequestBuilder<Void> {
        let localVariablePath = "/sms"
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "phoneNumberId": (wrappedValue: phoneNumberId?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = mailslurpAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Get reply for an SMS message
     
     - parameter smsId: (path)  
     - returns: Promise<ReplyForSms>
     */
    open class func getReplyForSmsMessage( smsId: UUID) -> Promise<ReplyForSms> {
        let deferred = Promise<ReplyForSms>.pending()
        getReplyForSmsMessageWithRequestBuilder(smsId: smsId).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get reply for an SMS message
     - GET /sms/{smsId}/reply
     - Get reply for an SMS message.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter smsId: (path)  
     - returns: RequestBuilder<ReplyForSms> 
     */
    open class func getReplyForSmsMessageWithRequestBuilder(smsId: UUID) -> RequestBuilder<ReplyForSms> {
        var localVariablePath = "/sms/{smsId}/reply"
        let smsIdPreEscape = "\(APIHelper.mapValueToPathItem(smsId))"
        let smsIdPostEscape = smsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{smsId}", with: smsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ReplyForSms>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Get SMS count
     
     - returns: Promise<CountDto>
     */
    open class func getSmsCount() -> Promise<CountDto> {
        let deferred = Promise<CountDto>.pending()
        getSmsCountWithRequestBuilder().execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get SMS count
     - GET /sms/count
     - Get number of SMS
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - returns: RequestBuilder<CountDto> 
     */
    open class func getSmsCountWithRequestBuilder() -> RequestBuilder<CountDto> {
        let localVariablePath = "/sms/count"
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<CountDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Get SMS content including body. Expects SMS to exist by ID. For SMS that may not have arrived yet use the WaitForController.
     
     - parameter smsId: (path)  
     - returns: Promise<SmsDto>
     */
    open class func getSmsMessage( smsId: UUID) -> Promise<SmsDto> {
        let deferred = Promise<SmsDto>.pending()
        getSmsMessageWithRequestBuilder(smsId: smsId).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get SMS content including body. Expects SMS to exist by ID. For SMS that may not have arrived yet use the WaitForController.
     - GET /sms/{smsId}
     - Returns a SMS summary object with content.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter smsId: (path)  
     - returns: RequestBuilder<SmsDto> 
     */
    open class func getSmsMessageWithRequestBuilder(smsId: UUID) -> RequestBuilder<SmsDto> {
        var localVariablePath = "/sms/{smsId}"
        let smsIdPreEscape = "\(APIHelper.mapValueToPathItem(smsId))"
        let smsIdPostEscape = smsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{smsId}", with: smsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<SmsDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getSmsMessagesPaginated: String, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**
     Get all SMS messages in all phone numbers in paginated form. .
     
     - parameter phoneNumber: (query) Optional receiving phone number to filter SMS messages for (optional)
     - parameter page: (query) Optional page index in SMS list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in SMS list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter unreadOnly: (query) Optional filter for unread SMS only. All SMS are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)
     - parameter since: (query) Optional filter SMSs received after given date time (optional)
     - parameter before: (query) Optional filter SMSs received before given date time (optional)
     - returns: Promise<PageSmsProjection>
     */
    open class func getSmsMessagesPaginated( phoneNumber: UUID? = nil,  page: Int? = nil,  size: Int? = nil,  sort: Sort_getSmsMessagesPaginated? = nil,  unreadOnly: Bool? = nil,  since: Date? = nil,  before: Date? = nil) -> Promise<PageSmsProjection> {
        let deferred = Promise<PageSmsProjection>.pending()
        getSmsMessagesPaginatedWithRequestBuilder(phoneNumber: phoneNumber, page: page, size: size, sort: sort, unreadOnly: unreadOnly, since: since, before: before).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get all SMS messages in all phone numbers in paginated form. .
     - GET /sms
     - By default returns all SMS messages across all phone numbers sorted by ascending created at date. Responses are paginated. You can restrict results to a list of phone number IDs. You can also filter out read messages
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter phoneNumber: (query) Optional receiving phone number to filter SMS messages for (optional)
     - parameter page: (query) Optional page index in SMS list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in SMS list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter unreadOnly: (query) Optional filter for unread SMS only. All SMS are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)
     - parameter since: (query) Optional filter SMSs received after given date time (optional)
     - parameter before: (query) Optional filter SMSs received before given date time (optional)
     - returns: RequestBuilder<PageSmsProjection> 
     */
    open class func getSmsMessagesPaginatedWithRequestBuilder(phoneNumber: UUID? = nil, page: Int? = nil, size: Int? = nil, sort: Sort_getSmsMessagesPaginated? = nil, unreadOnly: Bool? = nil, since: Date? = nil, before: Date? = nil) -> RequestBuilder<PageSmsProjection> {
        let localVariablePath = "/sms"
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "phoneNumber": (wrappedValue: phoneNumber?.encodeToJSON(), isExplode: true),
            "page": (wrappedValue: page?.encodeToJSON(), isExplode: true),
            "size": (wrappedValue: size?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
            "unreadOnly": (wrappedValue: unreadOnly?.encodeToJSON(), isExplode: true),
            "since": (wrappedValue: since?.encodeToJSON(), isExplode: true),
            "before": (wrappedValue: before?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PageSmsProjection>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Get unread SMS count
     
     - returns: Promise<UnreadCount>
     */
    open class func getUnreadSmsCount() -> Promise<UnreadCount> {
        let deferred = Promise<UnreadCount>.pending()
        getUnreadSmsCountWithRequestBuilder().execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get unread SMS count
     - GET /sms/unreadCount
     - Get number of SMS unread. Unread means has not been viewed in dashboard or returned in an email API response
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - returns: RequestBuilder<UnreadCount> 
     */
    open class func getUnreadSmsCountWithRequestBuilder() -> RequestBuilder<UnreadCount> {
        let localVariablePath = "/sms/unreadCount"
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<UnreadCount>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Send a reply to a received SMS message. Replies are sent from the receiving number.
     
     - parameter smsId: (path)  
     - parameter smsReplyOptions: (body)  
     - returns: Promise<SentSmsDto>
     */
    open class func replyToSmsMessage( smsId: UUID,  smsReplyOptions: SmsReplyOptions) -> Promise<SentSmsDto> {
        let deferred = Promise<SentSmsDto>.pending()
        replyToSmsMessageWithRequestBuilder(smsId: smsId, smsReplyOptions: smsReplyOptions).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Send a reply to a received SMS message. Replies are sent from the receiving number.
     - POST /sms/{smsId}/reply
     - Reply to an SMS message.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter smsId: (path)  
     - parameter smsReplyOptions: (body)  
     - returns: RequestBuilder<SentSmsDto> 
     */
    open class func replyToSmsMessageWithRequestBuilder(smsId: UUID, smsReplyOptions: SmsReplyOptions) -> RequestBuilder<SentSmsDto> {
        var localVariablePath = "/sms/{smsId}/reply"
        let smsIdPreEscape = "\(APIHelper.mapValueToPathItem(smsId))"
        let smsIdPostEscape = smsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{smsId}", with: smsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: smsReplyOptions)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<SentSmsDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }
}
